## 学习记录

### QT 信号 toggled triggered 区别

toggle 类似开关。 具有 2 个状态，打开/关闭。 使用这个信号，是在这 2 个状态之间切换。checkable 按纽或是图标的槽函数应该用 toggled()事件来激活

trigger 是一次性的。 点击后，无法改变状态。 要么是打开，要么是关闭。一般的按纽（uncheckable）的激活方式即是 triggered()。更有触发的意思。这个单词还有另一个意思就是板机

### super 面向对象 用法

在类的继承中，如果重定义某个方法，该方法会覆盖父类的同名方法，但有时，我们希望能同时实现父类的功能，这时，我们就需要调用父类的方法了。调用父类同名方法有两种方式：

1. 调用未绑定的父类方法
2. 使用 super 函数来调用

具体格式为:

```
super(cls,self).__init__(params)
```

`self`是当前类的实例, `cls`是当前类的类型, `params`是参数列表

### pyqt 子窗口实现

### python 嵌套调用

https://www.cnblogs.com/kuzaman/p/9606307.html

同样的问题也出现在 pyqt 中

https://www.bilibili.com/video/BV154411n79k?p=115#:~:text=no%20attribute%20Ui_MainWindow%E6%8A%A5-,%E9%94%99%E4%B8%8D%E7%9F%A5%E9%81%93%E5%92%8B%E8%A7%A3%E5%86%B3,-2020%2D05%2D19

### PointCloud 转 vtkPolyData

### vtk 平面选点

### 点云选点配准

#### 0. 问题提出——对应点变换矩阵求解

![](http://nghiaho.com/wp-content/uploads/2011/09/optimal_rotation_translation.png)

在研究点云手动选点配准的时候，遇到了一些技术上的困难，于是开始去读`Open3D`的例程，但是发现 C++封装传入的是点在点云数组中的位置 Index, 不适用 VTK 传回的点 xyz 坐标数据。于是在 github 上查找 Python 和 C++源码，然后注意到`Eigen::umeyama`，一个被`Eigen`封装好的经典算法，用于求解两列点对的坐标变换关系。

```cpp
Eigen::Matrix4d TransformationEstimationPointToPoint::ComputeTransformation(
        const geometry::PointCloud &source,
        const geometry::PointCloud &target,
        const CorrespondenceSet &corres) const {
    if (corres.empty()) return Eigen::Matrix4d::Identity();
    Eigen::MatrixXd source_mat(3, corres.size());
    Eigen::MatrixXd target_mat(3, corres.size());
    for (size_t i = 0; i < corres.size(); i++) {
        source_mat.block<3, 1>(0, i) = source.points_[corres[i][0]];
        target_mat.block<3, 1>(0, i) = target.points_[corres[i][1]];
    }
    return Eigen::umeyama(source_mat, target_mat, with_scaling_);
}
```

#### 1. `umeyama`算法学习

参考博客: [【Eigen 学习笔记】-- Umeyama](https://blog.csdn.net/weixin_42823098/article/details/111308627)

`umeyama`算法用于计算两组 2D 或 3D 数据之间的位置关系，由 Shinji Umeyama 于 1991 年提出。`Eigen`对其进行了封装，返回旋转与平移矩阵。算法的原始论文为: Least-squares estimation of transformation parameters between two point patterns", Shinji Umeyama, PAMI 1991, DOI: 10.1109/34.88573

对于扫描点云 A 和目标模型 B 对应的变换关系如下：
$$T \cdot A=B$$
$A=[p_1,p_2,p_3,...,p_n], B=[q_1,q_2,q_3,...,q_n]$

> 关于旋转平移矩阵的一些知识参考：[三维空间中的几何变换-平移旋转缩放](https://blog.csdn.net/swety_gxy/article/details/73087848)

算法的目标函数为：

$$err = \frac{1}{n} \sum_{i=1}^{n}\left\|q_{i}-\left(c R p_{i}+t\right)\right\|_{2}^{2}$$

其中，`c`是缩放系数，`R`是旋转矩阵，`t`是平移矩阵。其本质是*距离的平方和*，问题转化为一个最小二乘估计问题。

结果可以表示为：

$$
T = \left[\begin{array}{cc}
c R & t \\
0 & 1
\end{array}\right]
$$

#### 2. Python 中的`umeyama`实现

`umeyama`是一个很棒的算法，但是 Python 中无法直接使用`Eigen`，为了一个功能去绑定整个 C++库也并不值当，在看了很多无用的博客之后，终于找到了一个很棒的个人博客，博主是涉猎广泛，10 年博客平台，精华很多。  
博文地址：
[Finding optimal rotation and translation between corresponding 3D points](http://nghiaho.com/?page_id=671)  
代码地址：
[rigid_transform_3D](https://github.com/nghiaho12/rigid_transform_3D)

提供了 Python 和 Matlab 实现，这里仅展示 Python。

```Python
#!/usr/bin/python

import numpy as np

# Input: expects 3xN matrix of points
# Returns R,t
# R = 3x3 rotation matrix
# t = 3x1 column vector

def rigid_transform_3D(A, B):
    assert A.shape == B.shape

    num_rows, num_cols = A.shape
    if num_rows != 3:
        raise Exception(f"matrix A is not 3xN, it is {num_rows}x{num_cols}")

    num_rows, num_cols = B.shape
    if num_rows != 3:
        raise Exception(f"matrix B is not 3xN, it is {num_rows}x{num_cols}")

    # find mean column wise
    centroid_A = np.mean(A, axis=1)
    centroid_B = np.mean(B, axis=1)

    # ensure centroids are 3x1
    centroid_A = centroid_A.reshape(-1, 1)
    centroid_B = centroid_B.reshape(-1, 1)

    # subtract mean
    Am = A - centroid_A
    Bm = B - centroid_B

    H = Am @ np.transpose(Bm)

    # sanity check
    #if linalg.matrix_rank(H) < 3:
    #    raise ValueError("rank of H = {}, expecting 3".format(linalg.matrix_rank(H)))

    # find rotation
    U, S, Vt = np.linalg.svd(H)
    R = Vt.T @ U.T

    # special reflection case
    if np.linalg.det(R) < 0:
        print("det(R) < R, reflection detected!, correcting for it ...")
        Vt[2,:] *= -1
        R = Vt.T @ U.T

    t = -R @ centroid_A + centroid_B

    return R, t
```

**一些解释和知识点**

> numpy 矩阵运算符号  
> \*： 根据数据类型的不同，可能是做点乘运算，也可能做矩阵乘法运算  
> @： 只做矩阵乘法运算  
> .dot： 只做矩阵乘法运算  
> np.mutiply：只做点乘运算

###
